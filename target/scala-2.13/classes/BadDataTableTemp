package us.fringe.service.base.db

import com.github.javafaker.Faker
import slick.ast.BaseTypedType
import slick.jdbc.JdbcType
import slick.jdbc.PostgresProfile.api._
import us.fringe.service.base.model.integration.{IntegrationState, Slug}
import us.fringe.service.base.model.profile._

import java.time.LocalDateTime
import scala.concurrent.Future
import scala.language.implicitConversions

class AccountIntegrationTable(tag: Tag)
    extends Table[AccountIntegrationRecord](tag, Option("integration"), "account_integration") {

  implicit lazy val slugMapper: JdbcType[Slug] with BaseTypedType[Slug] = AccountIntegrationTable.slugMapper

  def id = column[Long]("id", O.PrimaryKey, O.AutoInc)
  def slug = column[Slug]("slug")
  def name = column[String]("name")
  def isPageActive = column[Boolean]("page_active")
  def pageHeader = column[Option[String]]("page_header")
  def pageText = column[Option[String]]("page_text")
  def pageLogoUrl = column[Option[String]]("page_logo_url")
  def connectUrl = column[Option[String]]("connect_url")
  def archivedAt = column[Option[LocalDateTime]]("archived_at")
  def * =
    (
      id,
      slug,
      name,
      isPageActive,
      pageHeader,
      pageText,
      pageLogoUrl,
      connectUrl,
      archivedAt
    ) <> (AccountIntegrationRecord.tupled, AccountIntegrationRecord.unapply)
}

object AccountIntegrationTable {
  implicit lazy val slugMapper: JdbcType[Slug] with BaseTypedType[Slug] =
    MappedColumnType
      .base[Slug, String](e => e.toString, s => Slug.withName(s))

  implicit def toAccountIntegrationLike(
      integrationConnectionAndFinchSync: (
          (
              AccountIntegrationRecord,
              Option[(AccountIntegrationConnectionRecord, Option[SlackMetadataRecord])]
          ),
          Option[FinchSyncRecord]
      )
  ): AccountIntegrationLike = {
    val integration = integrationConnectionAndFinchSync._1._1
    val connection = integrationConnectionAndFinchSync._1._2.map(_._1)
    val finchSync = integrationConnectionAndFinchSync._2
    val slackMetadata = integrationConnectionAndFinchSync._1._2.flatMap(_._2)

    if (finchSync.isDefined) {
      FinchAccountIntegration(
        id = integration.id,
        slug = integration.slug,
        name = integration.name,
        pageHeader = integration.pageHeader,
        pageText = integration.pageText,
        pageLogoUrl = integration.pageLogoUrl,
        connectUrl = integration.connectUrl,
        state = {
          if (connection.isDefined) connection.get.state
          else IntegrationState.None
        },
        lastSyncStatus = finchSync.get.status
      )
    } else {
      AccountIntegration(
        id = integration.id,
        slug = integration.slug,
        name = integration.name,
        pageHeader = integration.pageHeader,
        pageText = integration.pageText,
        pageLogoUrl = integration.pageLogoUrl,
        connectUrl = integration.connectUrl,
        state = {
          if (connection.isDefined) connection.get.state
          else IntegrationState.None
        },
        channel = slackMetadata.map(_.webhookChannel)
      )
    }
  }

  implicit def toUserAccountIntegration(
      integrationAndConnection: (
          AccountIntegrationRecord,
          Option[(AccountIntegrationConnectionRecord, Option[SlackMetadataRecord])]
      )
  ): UserAccountIntegration = {
    UserAccountIntegration(
      id = integrationAndConnection._1.id,
      slug = integrationAndConnection._1.slug,
      name = integrationAndConnection._1.name,
      state = integrationAndConnection._2.map(_._1.state).getOrElse(IntegrationState.None),
      channel = integrationAndConnection._2.flatMap(_._2.map(_.webhookChannel))
    )
  }

}

case class AccountIntegrationRecord(
    id: Long,
    slug: Slug,
    name: String,
    isPageActive: Boolean,
    pageHeader: Option[String],
    pageText: Option[String],
    pageLogoUrl: Option[String],
    connectUrl: Option[String],
    archivedAt: Option[LocalDateTime]
)

class AccountIntegrationFactory(val db: Database, val faker: Faker) {
  val accountIntegrations = TableQuery[AccountIntegrationTable]

  def build(
      slug: Slug = Slug.Slack,
      name: String = faker.company().name(),
      isPageActive: Boolean = true,
      pageHeader: Option[String] = Some(faker.lorem().sentence(5)),
      pageText: Option[String] = Some(faker.lorem().paragraph(3)),
      pageLogoUrl: Option[String] = Some(faker.internet().url()),
      connectUrl: Option[String] = Some(faker.internet().url()),
      archivedAt: Option[LocalDateTime] = None
  ): AccountIntegrationRecord = {
    AccountIntegrationRecord(
      id = 0,
      slug = slug,
      name = name,
      isPageActive = isPageActive,
      pageHeader = pageHeader,
      pageText = pageText,
      pageLogoUrl = pageLogoUrl,
      connectUrl = connectUrl,
      archivedAt = archivedAt
    )
  }

  def create(
      slug: Slug = Slug.Slack,
      name: String = faker.company().name(),
      isPageActive: Boolean = true,
      pageHeader: Option[String] = Some(faker.lorem().sentence(5)),
      pageText: Option[String] = Some(faker.lorem().paragraph(3)),
      pageLogoUrl: Option[String] = Some(faker.internet().url()),
      connectUrl: Option[String] = Some(faker.internet().url()),
      archivedAt: Option[LocalDateTime] = None
  ): Future[AccountIntegrationRecord] = {
    val integration = build(
      slug = slug,
      name = name,
      isPageActive = isPageActive,
      pageHeader = pageHeader,
      pageText = pageText,
      pageLogoUrl = pageLogoUrl,
      connectUrl = connectUrl,
      archivedAt = archivedAt
    )

    val insertAction = accountIntegrations returning accountIntegrations += integration
    db.run(insertAction)
  }

}
